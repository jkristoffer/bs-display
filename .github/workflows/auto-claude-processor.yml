name: Auto-Claude Issue Processor
on:
  workflow_dispatch:
    inputs:
      triggered_by:
        description: 'User who triggered the command'
        required: false
      comment_url:
        description: 'URL of the triggering comment'
        required: false
      scheduled_execution:
        description: 'Whether this is a scheduled execution'
        required: false
        default: 'false'

jobs:
  process-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup SSH key for VPS access
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DIGITALOCEAN_SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts
        
      - name: Setup DigitalOcean CLI
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
      
      - name: Spin up pre-configured VPS
        run: |
          echo "üöÄ Spinning up VPS for auto-claude processing..."
          ./dev/vps-scripts/spin-up-no-wait.sh auto-claude-worker
        
      - name: Wait for VPS to be ready
        run: |
          # Get the VPS IP with proper formatting
          VPS_IP=$(doctl compute droplet list --format "Name,PublicIPv4" --no-header | grep auto-claude-worker | awk '{print $2}')
          echo "VPS_IP=$VPS_IP" >> $GITHUB_ENV
          
          echo "üìç Found VPS IP: $VPS_IP"
          echo "‚è≥ Waiting for VPS to be ready at $VPS_IP..."
          
          # Add VPS to known hosts
          ssh-keyscan -H $VPS_IP >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Wait for SSH to be ready  
          for i in {1..30}; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o UserKnownHostsFile=/dev/null dev@$VPS_IP 'echo "SSH ready"' 2>/dev/null; then
              echo "‚úÖ VPS ready at $VPS_IP"
              break
            fi
            echo "‚è≥ Waiting for VPS... ($i/30)"
            sleep 10
            
            # Debug info every 5 attempts
            if [ $((i % 5)) -eq 0 ]; then
              DROPLET_STATUS=$(doctl compute droplet list --format "Name,Status" --no-header | grep auto-claude-worker | awk '{print $2}')
              echo "üîç Droplet status: $DROPLET_STATUS"
            fi
          done
          
          # Final check
          if ! ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 dev@$VPS_IP 'echo "Final SSH test"' 2>/dev/null; then
            echo "‚ùå SSH connection failed after timeout"
            echo "üîç Droplet info:"
            doctl compute droplet list | grep auto-claude-worker || echo "Droplet not found"
            exit 1
          fi
          
      - name: Process GitHub issues on VPS
        run: |
          echo "üß† Starting issue processing on VPS..."
          
          ssh -o StrictHostKeyChecking=no dev@$VPS_IP \
            'cd /opt/bs-display/dev && ./scripts/process-github-issues.sh'
          
      - name: Cleanup VPS
        if: always()
        run: |
          echo "üßπ Starting comprehensive VPS cleanup..."
          
          # First, try to clean up the specific droplet if we know its ID
          if [ -n "$VPS_IP" ]; then
            echo "üìç Cleaning up droplet with IP: $VPS_IP"
            DROPLET_ID=$(doctl compute droplet list --format ID,PublicIPv4 --no-header | grep "$VPS_IP" | awk '{print $1}' || true)
            if [ -n "$DROPLET_ID" ]; then
              echo "üóëÔ∏è  Deleting specific droplet: $DROPLET_ID"
              doctl compute droplet delete "$DROPLET_ID" --force || echo "Failed to delete specific droplet"
            fi
          fi
          
          # Then clean up any remaining auto-claude droplets
          echo "üîç Searching for any remaining auto-claude droplets..."
          AUTO_CLAUDE_DROPLETS=$(doctl compute droplet list --format ID,Name --no-header | grep "auto-claude" | awk '{print $1}' || true)
          
          if [ -n "$AUTO_CLAUDE_DROPLETS" ]; then
            echo "üóëÔ∏è  Found auto-claude droplets to clean up:"
            echo "$AUTO_CLAUDE_DROPLETS" | while read -r droplet_id; do
              if [ -n "$droplet_id" ]; then
                echo "  Deleting droplet: $droplet_id"
                doctl compute droplet delete "$droplet_id" --force || echo "Failed to delete droplet $droplet_id"
              fi
            done
          else
            echo "‚úÖ No auto-claude droplets found"
          fi
          
          # Finally, run general cleanup for any orphaned bs-display droplets
          echo "üßπ Running general bs-display cleanup..."
          ./dev/vps-scripts/cleanup.sh droplets --force || echo "General cleanup completed with warnings"
          
          echo "‚úÖ VPS cleanup completed"
        
      - name: Report completion
        if: github.event.inputs.comment_url
        run: |
          TRIGGERED_BY="${{ github.event.inputs.triggered_by }}"
          SCHEDULED="${{ github.event.inputs.scheduled_execution }}"
          
          if [ "$SCHEDULED" == "true" ]; then
            STATUS_MESSAGE="ü§ñ **Scheduled Auto-Claude Completed**
            
            ‚úÖ Processing completed as scheduled by @$TRIGGERED_BY
            
            Check the repository for any new PRs that were created."
          else
            STATUS_MESSAGE="ü§ñ **Auto-Claude Completed**
            
            ‚úÖ Processing completed immediately as requested by @$TRIGGERED_BY
            
            Check the repository for any new PRs that were created."
          fi
          
          # Post to the original comment thread
          gh api repos/${{ github.repository }}/issues/comments \
            --method POST \
            --field body="$STATUS_MESSAGE"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}